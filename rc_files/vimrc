set nocompatible              " be iMproved, required
set laststatus=2

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

Plugin 'VundleVim/Vundle.vim'
Plugin 'mileszs/ack.vim'
Plugin 'a.vim'
Plugin 'hari-rangarajan/cctree'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'vim-scripts/DoxygenToolkit.vim'
Plugin 'yggdroot/indentline'
Plugin 'cohama/lexima.vim'
Plugin 'scrooloose/nerdcommenter'
Plugin 'majutsushi/tagbar'
Plugin 'godlygeek/tabular'
Plugin 'mbbill/undotree'
Plugin 'SirVer/ultisnips'
Plugin 'honza/vim-snippets'
Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'dhruvasagar/vim-table-mode'
Plugin 'tpope/vim-fugitive'
Plugin 'airblade/vim-gitgutter'
Plugin 'flazz/vim-colorschemes'
Plugin 'kana/vim-submode'
Plugin 'ervandew/supertab'
Plugin 'ludovicchabant/vim-gutentags'
Plugin 'Valloric/YouCompleteMe'

" All of your Plugins must be added before the following line
"
call vundle#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
"
" Brief help
" :PluginList       - lists configured plugins
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line

"Remove all trailing whitespace by pressing F3
nnoremap <F3>        :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR>
nnoremap <leader>t   :TagbarOpen fj<CR>
nnoremap <leader>tx  :TagbarClose<CR>
nnoremap <leader>g   :GitGutterLineHighlightsToggle<CR>
nnoremap <leader>gp  :GitGutterPrevHunk<CR>
nnoremap <leader>gn  :GitGutterNextHunk<CR>
nnoremap <leader>gt  :GitGutterSignsToggle<CR>
nnoremap <leader>a   :bp<CR>
nnoremap <leader>d   :bn<CR>
nnoremap <leader>x   :bd<CR>
nnoremap <leader>i   :IndentLinesToggle<CR>
nnoremap <leader>h   :A<CR>
map <c-d>            :Dox<CR>
nnoremap <leader>f   :Ack<space>
nnoremap <leader>fs  :Ack<space><c-r>=expand("<cword>")<cr><CR>
nnoremap <leader>cr  :CCTreeTraceReverse<CR>
nnoremap <leader>cf  :CCTreeTraceForward<CR>
nnoremap <leader>n   :set invnumber<CR>
nnoremap <leader>u   :UndotreeToggle<cr>
nnoremap <silent> <Esc><Esc> <Esc>:nohlsearch<CR><Esc>
nnoremap <leader>c   :IndentLinesToggle<CR>:set invnumber<CR>:GitGutterSignsToggle<CR>
nnoremap <leader>]   :normal da}<CR>

set t_Co=256
set incsearch
set hlsearch
set hidden
set showmatch
set noswapfile
set wildmenu
set bs=2
syntax on
set nu
set tabstop=4 shiftwidth=4 expandtab
colo heroku-terminal
set undofile                " Save undos after file closes
set undodir=$HOME/.vim/undo " where to save undo histories
set undolevels=1000         " How many undos
set undoreload=10000        " number of lines to save for undo
set updatetime=5000
set textwidth=118

"folding settings
set foldmethod=indent   "fold based on indent
set foldnestmax=10      "deepest fold is 10 levels
set nofoldenable        "dont fold by default
set foldlevel=1         "this is just what i use

"if you want to highlight the whole line
"To highlight lines longer than 120 characters.
"augroup vimrc_autocmds
"    autocmd BufEnter * highlight OverLength ctermbg=red ctermfg=white guibg=#111111
"    autocmd BufEnter * match OverLength /\%120v.*/
"augroup END

"if you need to not pollute the whole line
highlight ColorColumn ctermbg=grey
call matchadd('ColorColumn', '\%120v', 100)

"to update/save after the file has been modified and no key has been pressed
"for update time
autocmd CursorHold,CursorHoldI * update

"To open file right where it was closed.
if has("autocmd")
    au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
                \| exe "normal! g'\"" | endif
endif

"Indent every file before saving
autocmd BufWritePre *.h :normal gg=G``
autocmd BufWritePre *.c :normal gg=G``

"Remove whitespace before saving
autocmd BufWritePre * :%s/\s\+$//e

"Open Tagbar by default for only C files
autocmd Filetype c :TagbarOpen

autocmd Filetype c :UltiSnipsAddFiletypes c.cpp
autocmd Filetype c :UltiSnipsAddFiletypes cpp.c

"Indent autowrap long lines before saving
"exe ':g/./normal gqq' | normal ``zz
" autocmd BufWritePre *.c :exe ':g/./normal gqq' | normal ``zz
" autocmd BufWritePre *.txt :g/./ normal gqq

"To clear the white space and indent the files after writing,
"TODO :
" air-line
let g:airline_powerline_fonts = 1

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif

" unicode symbols
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.branch = '⎇'
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '∥'
let g:airline_symbols.whitespace = 'Ξ'

" airline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = ''
let g:airline_theme='badwolf'

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#left_sep = ' '
let g:airline#extensions#tabline#left_alt_sep = '|'
let g:airline#extensions#tabline#formatter = 'default'

"For the CCTree
let g:CCTreeCscopeDb = "cscope.out"
let g:CCTreeRecursiveDepth = 3
let g:CCTreeMinVisibleDepth = 3

"tagbar
let g:tagbar_compact = 1

"gutentags
let g:gutentags_modules = ['ctags']
let g:gutentags_ctags_extra_args = ['--fields=+l --extra=+f --langdef=file']
let g:gutentags_project_root = ['.project']
let g:ctrlp_root_markers = ['.project']

"ycm
let g:ycm_show_diagnostics_ui = 0

" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

"make vim recognizing snippets dir
set runtimepath+=~/.vim/my-snippets/
" use different snippets dir
let g:UltiSnipsSnippetsDir='~/.vim/my-snippets/'
let g:UltiSnipsSnippetDirectories=["my-snippets"]

set listchars=tab:>-,trail:~,extends:>,precedes:<

"ycm no checking over the file size
let g:ycm_disable_for_files_larger_than_kb = 0

"ycm getting info from the tag file
let g:ycm_collect_identifiers_from_tags_files = 1

"search the word under the cursor using ack
let g:ack_use_cword_for_empty_search = 0

"space between comment and stuff like that
let NERDSpaceDelims=0
let NERDDefaultAlign='left'
let g:NERDAltDelims_c = 1
let g:NERDAltDelims_cpp = 1

" Create a submode to handle windows
" The submode is entered whith <Leader>w and exited with <Leader>
call submode#enter_with('WindowsMode', 'n', '', '<Leader>w', ':echo "windows mode"<CR>')
call submode#leave_with('WindowsMode', 'n', '', '<Esc>')

" Change of windows with hjkl
call submode#map('WindowsMode', 'n', '', 'j', '<C-w>j')
call submode#map('WindowsMode', 'n', '', 'k', '<C-w>k')
call submode#map('WindowsMode', 'n', '', 'h', '<C-w>h')
call submode#map('WindowsMode', 'n', '', 'l', '<C-w>l')

" Resize windows with <C-yuio> (interesting on azerty keyboards)
call submode#map('WindowsMode', 'n', '', '-', '<C-w>-')
call submode#map('WindowsMode', 'n', '', '+', '<C-w>+')
call submode#map('WindowsMode', 'n', '', '<', '<C-w><')
call submode#map('WindowsMode', 'n', '', '>', '<C-w>>')

call submode#map('WindowsMode', 'n', '', 'w', '<C-w><C-w>')

let g:submode_keep_leaving_key = 0
let g:submode_timeout = 0

let g:DoxygenToolkit_compactDoc = "yes"

let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
if executable('ag')
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
endif
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_regexp = 1
